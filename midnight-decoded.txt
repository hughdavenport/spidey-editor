UNKNOWN #2: [0x01, 0x00, 0x02, 0x18, 0x00]
Left over data (length=37): [0x2f, 0xa8, 0x87, 0x7a, 0x24, 0x91, 0x59, 0x00, 0x53, 0x02, 0x24, 0x8e, 0x84, 0x2f, 0x00, 0x44, 0x50, 0x00, 0x33, 0xae, 0x58, 0x02, 0x09, 0x93, 0xb3, 0x35, 0x00, 0x49, 0x2e, 0x0a, 0xe0, 0x60, 0x27, 0x0d, 0xe0, 0x00, 0x00]
room data before unknown (0x2c9)

movertab.dat layout:
struct{
    u8 delta_x;
    u8 delta_y;
    u8 type;
    // bottom threee bits of type are an index into a u16 table 0xa9e3 (1000:8e11 in ghidra)
    // that table is a further delta_x/y pair
}

files
movertab.dat 0xfb9:0x1d4e (0x118de) size 0x0300 to 0x0fb9:0819-0b19 (0x103a9-0x106a9)
                                                to 0x0fb9:0150-0450 (0x0fce0-0x0ffe0)
charset.ega  0xfb9:0x1d21 (0x118b1) size 0x1000 to 0x0fb9:0b19-1c19 (0x106a9-0x118a9)
charset.cga  0xfb9:0x1d2e (0x118be) size 0x0800 to 0x0fb9:0b19-1b19 (0x106a9-0x116a9)
backs.spl    0xfb9:0x1d3a (0x118ca) size 0x3000 to 0x0fb9:3225-6225 (0x12db5-0x15db5)
rooms.spl    0xfb9:0x1d44 (0x118d4) size 0x3000 to 0x0fb9:6225-9225 (0x15db5-0x18db5)

spidfigr.ega 0x1a6a:0x44  (0x1a6e4) size 0x1800 to 0x1a6a:0090-1890 (0x1a730-0x1bf30)
spidfigr.cga 0x1a6a:0x51  (0x1a6d9) size 0x0c00 to 0x1a6a:0090-0c90 (0x1a730-0x1b330)
skelfigr.ega 0x1a6a:0x5e  (0x1a6fe) size 0x1800 to 0x1a6a:1890-3090 (0x1bf30-0x1d730)
skelfigr.cga 0x1a6a:0x6b  (0x1a6eb) size 0x0c00 to 0x1a6a:1890-2490 (0x1bf30-0x1cb30)
spids1.ega   0x1a6a:2     (0x1a6a2) size 0x4000 to 0x1a6a:3090-7090 (0x1d730-0x21730)
spids1.cga   0x1a6a:0x18  (0x1a6b8) size 0x2000 to 0x1a6a:3090-5090 (0x1d730-0x1f730)
spids2.ega   0x1a6a:0xd   (0x1a6ad) size 0x4000 to 0x1a6a:7090-b090 (0x21730-0x25730)
spids2.cga   0x1a6a:0x23  (0x1a6c3) size 0x2000 to 0x1a6a:5090-7090 (0x1f730-0x21730)
mask2.cga    0x1a6a:0x39  (0x1a6d9) size 0x2000 to 0x1a6a:9090-b090 (0x23730-0x25730)
mask1.cga    0x1a6a:0x2e  (0x1a6ce) size 0x2000 to 0x1a6a:7090-9090 (0x21730-0x23730)
hiscore.ega  0x1a6a:0x78  (0x1a718) size 0x17c0 to 0x1a6a:b090-c850 (0x25730-0x26ef0)
hiscore.cga  0x1a6a:0x84  (0x1a704) size 0x0be0 to 0x1a6a:b090-bc70 (0x25730-0x26310)

blocks.ega   0x26ef:0     (0x26ef0) size 0x4000 to 0x26ef:0031-4031 (0x26f21-0x2af21)
blocks.cga   0x26ef:0xd   (0x26efd) size 0x2000 to 0x26ef:0031-2031 (0x26f21-0x28f21)
scenery.ega  0x26ef:0x18  (0x26f08) size 0x2000 to 0x26ef:4037-6037 (0x2af27-0x2cf27)
scenery.cga  0x26ef:0x25  (0x26f15) size 0x1000 to 0x26ef:4037-5037 (0x2af27-0x2bf27)

loadscrn     0x0010:0x0   (0x00100) size 0x7d00 to 0x0010:009b-7d9b (0x0019b-0x07e9b)
page1        0x0010:0x33  (0x00133) size 0x7d00 to 0x0010:7d9b-fb36 (0x07e9b-0x0fc36)
page2        0x0010:0x4d  (0x0014d) size 0x7d00 to 0x0010:7d9b-fb36 (0x07e9b-0x0fc36)
page3        0x0010:0x67  (0x00167) size 0x7d00 to 0x0010:7d9b-fb36 (0x07e9b-0x0fc36)
page4        0x0010:0x81  (0x00181) size 0x7d00 to 0x0010:7d9b-fb36 (0x07e9b-0x0fc36)
winscrn      0x0010:0x1a  (0x0011a) size 0x7d00 to 0x0010:7d9b-fb36 (0x07e9b-0x0fc36)


ES set to 0xfb9 at start of real_entry (1000:2f3e)
DS same

DS set to 0x1a6a at 1000:3078
reads to 0x7090-b090 at 1000:308f
DS = 0x26ef at 1000:30b9
DS = ES at 1000:30d5
DS = 0x1a6a at 1000:315f
reads to 0x9090-b090 at 1000:3191
DS = 0x26ef at 1000:31bb
DS = ES at 1000:31d7
reads backs.spl (0x1d3a) and movertab.dat (0x1d4e) at 1000:31f1
DS AND ES = 0xfb9 at 1000:31f7 (same as start of entry)
reads rooms.spl at 1000:320e




memory:
0x1b39 = 0x1b5c

struct {
    0x1b49   = 0x2f   (first byte)
    0x1b4a-b = 0x0f08 (offset to heli switch) // x = byte1 & 0x1f, y = byte2 & 0x1f
    0x1b4c-d = 0x0150 (index into movertab.dat (i = 0))
    0x1b4e-f = 0x0206 (dimensions of list below
list of switch tiles (2 * 6) [
    0x1b50 = 0x69 (heli top)
    0x1b51 = 0x6a (heli top)
    0x1b52 = 0x6b (heli top)
    0x1b53 = 0x6c (heli top)
    0x1b54 = 0x6c (heli top)
    0x1b55 = 0x6d (heli top)
    0x1b56 = 0x00 (heli bottom)
    0x1b57 = 0x6e (heli bottom)
    0x1b58 = 0x6f (heli bottom)
    0x1b59 = 0x00 (heli bottom)
    0x1b5a = 0x00 (heli bottom)
    0x1b5b = 0x00 (heli bottom)
]
}
struct {
    0x1b5c    = 0x87   (first byte)
    0x1b5d-e  = 0x071a (offset to r2d2) // x = byte1 & 0x1f, y = byte2 & 0x1f
    0x1b5f-60 = 0x0153 (index into movertab.dat (i = 1))
    0x1b61-2  = 0x92ec (bp + 0x32) (address of more stuff (bp)
}
no more objects

0x1c89 = 0x1b3d

0x1c8b = 0x01

0x1d12 = unknown2[3] >> 2 = 0x06

0x9293 = 0x0002

bp {
    +0x00   0x92ec    = 0x04 (static)
    +0x01-2 0x92ed-f  = (0x00d0 + (u8)*0xab37) - 0xa = 0x00e8 (x + movertab[].delta_x + delta_table[movertab[].type & 0x7])
                      = later gets set to 0xed   // ax = delta_table[delta_table[movertab[].type & 0x7]].1 + ((x + movertab[].delta_x + delta_table[movertab[].type & 0x7] + 0xa) & 0xf8) - 0xa
        bp[0x1] = ax
    +0x03   0x92ef    = (0x38 + *0xab36) - 0xa       = 0x2f   (same but for y, and only a byte)
                      = later gets set to 0x35   // al = delta_table[delta_table[movertab[].type & 0x7]].0 + (bp[0x3] + 0xa) & 0xf8) - 0xa
    +0x04   0x92f0    = 0x00 (movertab[i].type & 0x7)
    +0x05   0x92f1    = 0x5f (static)
..
    +0x10   0x92fc    = 0x00 (*(uint8_t*)(unknown_static_table[((((first&0x60)>>2)|(second&0xe0))>>1) + 0]))
..
    +0x12-3 0x92fe-f  - bx (pointer to just after what was stored in 0x18-19 (1000:27f9)
..
    +0x18-9 0x9304-5  - 0x0000 (pulled from pointer just before whats stored at 0x12-3
..
    +0x1e   0x930a    = 0x0153
..
    +0x26   0x9312    = 0x00 (movertab[][2] & 0x2 == 0 ? 0x00 : bp[0x2f])
..
    +0x29-a 0x9315-6  = 0xa4e5 (unknown_static_table[((((first&0x60)>>2)|(second&0xe0))>>1) + 0] + 1)
    +0x2b-c 0x9316-7  = bp[1]
    +0x2d   0x9318    = bp[3]
    +0x2e   0x9319    = bp[4]
    +0x2f   0x931b    = 0xc0 (unknown_static_table[((((first&0x60)>>2)|(second&0xe0))>>1) + 3])
    +0x30   0x931c    = 0x01 (unknown_static_table[((((first&0x60)>>2)|(second&0xe0))>>1) + 4])
    +0x31   0x931d    = 0x00 (static)
}

0x9382 = *(((u16*)bx)++)
0x968e - points to room

0x9690 = unknown2[4] << 8 | unknown2[3] & 0x3 = 0x00

unknown2[
0 - unused
1 - number of 3 byte structures
2 - first loop counter (number of moving items, ie heli and r2d2)
3 - counter lsb & 0x3
4 - counter msb
]


walkthrough
mov [0x968e], si
mov cl, [si + 0x2cc] >> 2 (unknown2[3] 0x18 >> 2 = 0x6)
0x1d12 = cl
mov bh, [si + 0x2cd] (unknown2[4] = 0x00)
mov bl, [si + 0x2cc] & 0x3 (unknown2[3] 0x18 & 0x3 = 0x00)
0x9690 = bx
0x1c8b = 0x00
0x9293 = ax = 0x0001
0x1c89 = bx = 0x1b39
bx = 0x150 + 3 * [si + 0x2ca] (unknown2[1] 0x00 = 0x150) (index into movertab.dat)
cl = [si + 0x2cb] (unknown2[2] = 0x02)
si += 0x2e6 (points at rest now)
di = 0x1b49
looping twice (cl = 0x2) {
    tmp_bx = *0x1c89 = 0x1b39
    *0x1b39 = di = 0x1b49
    tmp_bx += 2 = 0x1b3b
    0x1c89 = tmp_bx = 0x1b3b (from 0x1b39)
    [di + 0x3] = bx => *0x1b4c = 0x0150
    ax = si[0-1] = rest[0-1] = 0x2fa8
    si += 2 (points at rest[2])
    [di] = ah => *0x1b49 = 0x2f
    test ah & 0x80 (0x2f & 0x80 = ZERO, branch)
    dx = ax = 0x2fa8
    ax &= 0x1f1f = 0x0f08 (tile index)
    di[1] = ax => *0x1b4a = 0x0f08
    *0x1c8b ++ (now 0x01)
    dx &= 0x60e0 = 0x20a0
    dx >>= 5 (/32) = 0x0105
    dl,dh++ = 0x0206
    di[5] = dx => *0x1b4e = 0x0206
    di += 7 = 0x1b50
    tmp_bx = *0x968e = room pointer
    tmp_bl += al (0x08 = 0x96, no carry)
    tmp_bh += 0 + c (nop)
    al = 0
    ax >>= 3 (0x0f00 = 0x1e0)
    tmp_bx += ax (= roomp + 0x1e8)
    ah = 0 (ax = 0x00e8)
    loop_dh (0x02) { // height of heli
        loop_dl (0x06) (i = 0..6) { // length of heli
            al = *tmp_bx (roomp[0x1e8 + i] = 0x69, heli switch)
            *di = al (*0x1b50 = 0x69)
            *tmp_bx = ah = (roomp[0x1e8 + i] = 0x00, clears it? I guess it's in a structure now)
        }
        tmp_bx += 0x20 (next row down)
    }
    di is 12 more, now 0x1b5c
    // reads original tile data of the helicopter
    bx = back to 0x150
    bx += 3 (0x153)
} second loop through (i=1) {
    tmp_bx = *0x1c89 = 0x1b3b
    *0x1b3b = di = 0x1b5c
    tmp_bx += 2 = 0x1b3d
    0x1c89 = tmp_bx = 0x1b3d
    [di + 0x3] = bx => *0x1b5f = 0x0153
    ax = si[0-1] = rest[2-3] = 0x877a
    si += 2 (points at rest[4])
    [di] = ah => *0x1b5c = 0x87
    test ah & 0x80 (0x87 & 0x80 = NOT ZERO, no branch)
    ...
    ... fun 1000:4200
    inc *0x9293 = 0x0002 now
    bp += 0x32 (bp was 0x92ba, so now 0x92ec)
    di[5] = bp (*0x1b61 = 0x92ec)
    bp[0x1e] = bx (*0x930a = 0x0153)
    bp[0x5] = 0x5f (*0x92f1 = 0x5f)
    tmp_ax &= 0x1f1f (0x071a) (masked tile, points to r2d2)
    // x = byte1 & 0x1f, y = byte2 & 0x1f
    di[1] = tmp_ax (*0x1b5d = 0x071a)
    ...
    tmp_ah += bx[0] (*0x0153 => ???) (movertab.dat, starts at 0x150
    tmp_al += bx[1] (*0x0154 => ???)
    // both 0 in file, so no change from 0x071a
    // might be starting location of enemy, points to r2d2
    dl = tmp_ah (0x07)
    dl *= 8 (0x38)
    tmp_ax = sign extend al (0x001a)
    tmp_ax *= 8 (0x00d0)
    tmp_bl = bx[2] & 0x7 (*0x0155 movertab is 0xb8) = 0x0
    bp[4] = tmp_bl (*0x92f0 = 0x00)
    tmp_bl *= 2
    tmp_bh = 0
    tmp_bx += 0xa9e3 (0x153=> 0xa9e3)
**  cx = *tmp_bx (dnno what is here???, maybe 1000:8e11 in ghidra, based on offset of 0x1762. used (ds*0x10 + addr - 0x1762) - 0x10000
       *** it's actually 1000:2cef in ghidra, confirmed with debugger
       = 0x0707)
    dl += ch (0x38 + *0xab36) - 0xa = 0x35
    bp[3] = dl
    // dl = x + movertab[i].delta_x + delta_table[movertab[i].type & 0x7].x - 10
    ch = 0
    tmp_ax += cx (0x00d0 + *0xab37) - 0xa = 0xe8
    // ax = y + movertab[i].delta_y + delta_table[movertab[i].type & 0x7].y - 10
    bp[1] = tmp_ax
    bp[0] = 0x04
    ax = 0x877a again (first two bytes)
    ax &= 0x60e0 (0x0060)
    ah >>= 2 (/4 0x0)
    al = (0x0 | 0x60)
    al >>= 2 (/4 0x18)
    ah = 0
    ax = 0x0018
    ax *= 2 (0x0030)
    bx = 0xa9f3 (1000:2cff in ghidra)
    bx += ax (0xaa23)
**  al = bx[3] (*0xaa26 = ??, perhaps it is 1000:8e51 in ghidra, based on the location of "rooms.spl" is 1000:0172, and should be fb9:1d44, diff of 0x1762)
        ** this is actually 1000:2d2f + 3
        = 0xc0
    ah = bx[2] (0x01)
    bp[0x2f] = al (unknown_static_table[((((first&0x60)>>2)|(second&0xe0))>>1) + 3]
    bp[0x30] = ah (unknown_static_table[((((first&0x60)>>2)|(second&0xe0))>>1) + 4]
    bp[0x31] = 0x00

    bx = (unknown_static_table[((((first&0x60)>>2)|(second&0xe0))>>1) + 0]
       = 0xa4e4 (from *0xaa23)
          (in ghidra this is 1000:27f0)
    al = *bx = 0x00
    bp[0x10] = al (*(uint8_t*)(unknown_static_table[((((first&0x60)>>2)|(second&0xe0))>>1) + 0]))
    bx ++ (0xa4e5 (1000:27f1))
    fun_1000:3ed4
    ..
    bp[0x29-a] = bx (unknown_static_table[((((first&0x60)>>2)|(second&0xe0))>>1) + 0] + 1
    ax = bp[1] ( (0x00d0 + (u8)*0xab37) - 0xa = 0x00e8 (x + movertab[].delta_x + delta_table[movertab[].type & 0x7]))
    bp[0x2b-c] = bp[1-2]
    bp[0x2d] = (u8)bp[3]
    bp[0x2e] = (u8)bp[4]
    while ((al = *(bx++)) != 0x80) {}
    // counts 3 more from before the function was called in this run through
    .. end fun_1000:3ed4
    fun_1000:3ed8
    ..
    bp[0x14-5] = *(((u16*)bx)++) (0xa582)
    if bp[0x10] & 0x2 != 0 {
        // n/e
    }
    cx = *bx (0x0000)
    al = bp[4] (type of enemy? & 0x7) = 0x00
    fun_1000:41af
    ...
    tweaks cx based on bottom 3 bits of al
    in our case, no change
    ...
    if (bp[0x10] & 0x1 != 0) {
        // n/e
    }
    bp[0x18-9] = cx (0x0000)
    bx += 2 (1000:27f9)
    bp[0x12-3] = bx
    if (bp[0x10] & 0x1 == 0 {
        bl = bp[0x4]     => 0x00 (movertab[i].type & 0x7)
        bl *= 2
        bh = 0
        bx += 0xa9e3 (delta_table)
        cx = *bx (0x0707)
        al = bp[0x3]     => (0x38 + *0xab36) - 0xa       = 0x2f   (y + movertab[].delta_y + delta_table[movertab[].type & 0x7])
        al += 0xa (0x39)
        al &= 0xf8 (0x38)
        al += ch (0x38 + 0x07 = 0x3f)
        al -= 0xa = (0x35)
        // al = delta_table[delta_table[movertab[].type & 0x7]].0 + ((y + movertab[].delta_y + delta_table[movertab[].tye & 0x7] + 0xa) & 0xf8) - 0xa
        bp[0x3] = al
        ch = 0
        ax = bp[0x1]   => (0x00d0 + (u8)*0xab37) - 0xa = 0x00e8 (x + movertab[].delta_x + delta_table[movertab[].type & 0x7])
        ax += 0xa (0xf2)
        al *= 0xf8 (0xf0)
        ax += cx (0xf0 + 0x07 = 0xf7)
        ax -= 0xa (0xed)
        // ax = delta_table[delta_table[movertab[].type & 0x7]].1 + ((x + movertab[].delta_x + delta_table[movertab[].type & 0x7] + 0xa) & 0xf8) - 0xa
        bp[0x1] = ax
    }
    .. end fun_1000:3ed8
    bx = bp[0x1e]      +0x1e   0x930a    = 0x0153
    al = bp[0x2f]      +0x2f   0x931b    = 0xc0 (unknown_static_table[((((first&0x60)>>2)|(second&0xe0))>>1) + 3])
    if (bx[0x2] & 0x2 == 0) { // movertab[][2] = 0xb8
        al = 0
    }
    bp[0x26] = al (0x00)
    di += 0x7 (0x1b63)
    bx = orig_bx
    cx = orig_cx
    ... end fun 1000:4200
    ...
    bx += 3 (0x156)
}
