UNKNOWN #2: [0x01, 0x00, 0x02, 0x18, 0x00]
Left over data (length=37): [0x2f, 0xa8, 0x87, 0x7a, 0x24, 0x91, 0x59, 0x00, 0x53, 0x02, 0x24, 0x8e, 0x84, 0x2f, 0x00, 0x44, 0x50, 0x00, 0x33, 0xae, 0x58, 0x02, 0x09, 0x93, 0xb3, 0x35, 0x00, 0x49, 0x2e, 0x0a, 0xe0, 0x60, 0x27, 0x0d, 0xe0, 0x00, 0x00]
room data before unknown (0x2c9)


memory:
0x1b39 = 0x1b5c

struct {
    0x1b49   = 0x2f
    0x1b4a-b = 0x0f08 (offset to heli switch)
    0x1b4c-d = 0x0150
    0x1b4e-f = 0x0206 (dimensions of list below
}
list of switch tiles {
    0x1b50 = 0x69 (heli)
    0x1b51 = 0x6a (heli)
    0x1b52 = 0x6b (heli)
    0x1b53 = 0x6c (heli)
    0x1b54 = 0x6c (heli)
    0x1b55 = 0x6d (heli)
    0x1b56 = 0x00 (heli)
    0x1b57 = 0x6e (heli)
    0x1b58 = 0x6f (heli)
    0x1b59 = 0x00 (heli)
    0x1b5a = 0x00 (heli)
    0x1b5b = 0x00 (heli)
}
struct {
    0x1b5c   =
    0x1b5d-e =
    0x1b5f-g = 0x0153

0x1c89 = 0x1b3d

0x1c8b = 0x01

0x1d12 = unknown2[3] >> 2 = 0x06

0x9293 = 0x0002

0x968e - points to room

0x9690 = unknown2[4] << 8 | unknown2[3] & 0x3 = 0x00

unknown2[
0 - unused
1 - number of 3 byte structures
2 - first loop counter
3 - counter lsb & 0x3
4 - counter msb
]


walkthrough
mov [0x968e], si
mov cl, [si + 0x2cc] >> 2 (unknown2[3] 0x18 >> 2 = 0x6)
0x1d12 = cl
mov bh, [si + 0x2cd] (unknown2[4] = 0x00)
mov bl, [si + 0x2cc] & 0x3 (unknown2[3] 0x18 & 0x3 = 0x00)
0x9690 = bx
0x1c8b = 0x00
0x9293 = ax = 0x0001
0x1c89 = bx = 0x1b39
bx = 0x150 + 3 * [si + 0x2ca] (unknown2[1] 0x00 = 0x150)
cl = [si + 0x2cb] (unknown2[2] = 0x02)
si += 0x2e6 (points at rest now)
di = 0x1b49
looping twice (cl = 0x2) {
    tmp_bx = *0x1c89 = 0x1b39
    *0x1b39 = di = 0x1b49
    tmp_bx += 2 = 0x1b3b
    0x1c89 = tmp_bx = 0x1b3b (from 0x1b39)
    [di + 0x3] = bx => *0x1b4c = 0x0150 (then 
    ax = si[0-1] = rest[0-1] = 0x2fa8
    si += 2 (points at rest[2])
    [di] = ah => *0x1b49 = 0x2f
    test ah & 0x80 (0x2f & 0x80 = ZERO, branch)
    dx = ax = 0x2fa8
    ax &= 0x1f1f = 0x0f08 (tile index)
    di[1] = ax => *0x1b4a = 0x0f08
    *0x1c8b ++ (now 0x01)
    dx &= 0x60e0 = 0x20a0
    dx >>= 5 (/32) = 0x0105
    dl,dh++ = 0x0206
    di[5] = dx => *0x1b4e = 0x0206
    di += 7 = 0x1b50
    tmp_bx = *0x968e = room pointer
    tmp_bl += al (0x08 = 0x96, no carry)
    tmp_bh += 0 + c (nop)
    al = 0
    ax >>= 3 (0x0f00 = 0x1e0)
    tmp_bx += ax (= roomp + 0x1e8)
    ah = 0 (ax = 0x00e8)
    loop_dh (0x02) { // height of heli
        loop_dl (0x06) (i = 0..6) { // length of heli
            al = *tmp_bx (roomp[0x1e8 + i] = 0x69, heli switch)
            *di = al (*0x1b50 = 0x69)
            *tmp_bx = ah = (roomp[0x1e8 + i] = 0x00, clears it? I guess it's in a structure now)
        }
        tmp_bx += 0x20 (next row down)
    }
    di is 12 more, now 0x1b5c
    // reads original tile data of the helicopter
    bx = back to 0x150
    bx += 3 (0x153)
} second loop through {
    tmp_bx = *0x1c89 = 0x1b3b
    *0x1b3b = di = 0x1b5c
    tmp_bx += 2 = 0x1b3d
    0x1c89 = tmp_bx = 0x1b3d
    [di + 0x3] = bx => *0x1b5f = 0x0153
    ax = si[0-1] = rest[2-3] = 0x877a
    si += 2 (points at rest[4])
    [di] = ah => *0x1b5c = 0x87
    test ah & 0x80 (0x87 & 0x80 = NOT ZERO, no branch)
    ...
    ... fun 1000:4200
    inc *0x9293 = 0x0002 now
    bp += 0x32 (bp was 0x92ba, so now 0x92ec)
    ...
    bx += 3 (0x156)
}
